using System.Collections.Concurrent;
using System.Runtime.Versioning;
using ElkCreekServices.OpenScripts.Logging.Configurations;
using ElkCreekServices.OpenScripts.Logging.Factory;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace ElkCreekServices.OpenScripts.Logging.Providers;

/// <summary>
/// A logger provider that creates a rotating file logger
/// </summary>
[UnsupportedOSPlatform("browser")]
[ProviderAlias("RotatingFile")]
public sealed class RotatingFileLoggerProvider : ILoggerProvider
{

    private readonly IDisposable? _onchangeToken;
    private readonly ConcurrentDictionary<string, RotatingLoggerConfiguration> _configurations = new(StringComparer.OrdinalIgnoreCase);
    private readonly ConcurrentDictionary<string, RotatingFileLoggerFactory> _loggers = new(StringComparer.OrdinalIgnoreCase);

    public RotatingFileLoggerProvider(IOptionsMonitor<RotatingLoggerConfigurations> config)
    {
        AddOrUpdateConfigurations(config.CurrentValue);
        _onchangeToken = config.OnChange(AddOrUpdateConfigurations);     
    }

    private void AddOrUpdateConfigurations(RotatingLoggerConfigurations updatedConfig)
    {
        System.Diagnostics.Trace.WriteLine("RotatingFileLoggerProvider.AddOrUpdateConfigurations executing");

        foreach (RotatingLoggerConfiguration configuration in updatedConfig.Configurations)
        {
            _configurations.AddOrUpdate(configuration.Name ?? "default", configuration, (key, oldValue) =>
            {
                oldValue.AutoGenerateDirectory = configuration.AutoGenerateDirectory ?? oldValue.AutoGenerateDirectory;
                oldValue.AttemptAutoFileRenameOnIOException = configuration.AttemptAutoFileRenameOnIOException ?? oldValue.AttemptAutoFileRenameOnIOException;
                oldValue.ConsoleLoggingEnabled = configuration.ConsoleLoggingEnabled ?? oldValue.ConsoleLoggingEnabled;
                oldValue.ConsoleMinLevel = configuration.ConsoleMinLevel;
                oldValue.Filename = configuration.Filename ?? oldValue.Filename;
                oldValue.IncludeDateTime = configuration.IncludeDateTime ?? oldValue.IncludeDateTime;
                oldValue.IsUtcTime = configuration.IsUtcTime ?? oldValue.IsUtcTime;
                oldValue.LogLevel = configuration.LogLevel;
                oldValue.MaximumLogFileSizeKB = configuration.MaximumLogFileSizeKB ?? oldValue.MaximumLogFileSizeKB;
                oldValue.Name = configuration.Name ?? oldValue.Name;
                oldValue.PurgeAfterDays = configuration.PurgeAfterDays ?? oldValue.PurgeAfterDays ;

                return oldValue;
            });
        }
    }

    /// <summary>
    /// Create a logger
    /// </summary>
    /// <param name="categoryName"></param>
    /// <returns></returns>
    public ILogger CreateLogger(string categoryName)
    {
        if (_configurations.ContainsKey(categoryName?.Split('.').Last()!))
        {
            return new RotatingFileLogger(_loggers.GetOrAdd(categoryName!, name =>
            new RotatingFileLoggerFactory(name, () => _configurations[name.Split('.').Last()!])));
        }
        else
        {
            return new RotatingFileLogger(_loggers.GetOrAdd("default", name =>
            new RotatingFileLoggerFactory(name, () => _configurations.GetOrAdd(name, name => new RotatingLoggerConfiguration()))));
        }
    }

    /// <summary>
    /// Dispose
    /// </summary>
    /// <exception cref="Exception"></exception>
    public void Dispose()
    {
        //dispose all loggers in parallel to avoid extensive blocking
        var result = Parallel.ForEach(_loggers, logger => logger.Value.Dispose());
        if (!result.IsCompleted)
        {
            throw new Exception("Failed to dispose all loggers");
        }
        _loggers.Clear();
        _onchangeToken?.Dispose();
    }
}
